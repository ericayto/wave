#!/usr/bin/env python3
"""
Wave - Local LLM-Driven Crypto Trading Bot
CLI Bootstrap for starting and managing Wave services.
"""

import os
import sys
import subprocess
import signal
import time
import argparse
from pathlib import Path
import json
import datetime

# Add the project root to Python path
PROJECT_ROOT = Path(__file__).parent.absolute()
sys.path.insert(0, str(PROJECT_ROOT))

# Auto-update configuration
GITHUB_REPO_URL = "https://github.com/ericayto/wave.git"
UPDATE_CHECK_FILE = PROJECT_ROOT / ".last_update_check"
UPDATE_INTERVAL_HOURS = 24  # Check for updates once per day

def should_check_for_updates():
    """Check if we should perform an update check based on last check time."""
    if not UPDATE_CHECK_FILE.exists():
        return True
    
    try:
        with open(UPDATE_CHECK_FILE, 'r') as f:
            data = json.load(f)
        
        last_check = datetime.datetime.fromisoformat(data.get('last_check', ''))
        now = datetime.datetime.now()
        hours_since_check = (now - last_check).total_seconds() / 3600
        
        return hours_since_check >= UPDATE_INTERVAL_HOURS
    except (json.JSONDecodeError, ValueError, KeyError):
        return True

def update_last_check_time():
    """Update the last update check timestamp."""
    data = {
        'last_check': datetime.datetime.now().isoformat(),
        'last_update': datetime.datetime.now().isoformat()
    }
    
    with open(UPDATE_CHECK_FILE, 'w') as f:
        json.dump(data, f, indent=2)

def check_if_git_repo():
    """Check if the current directory is a git repository."""
    git_dir = PROJECT_ROOT / ".git"
    return git_dir.exists()

def get_current_commit_hash():
    """Get the current commit hash."""
    try:
        result = subprocess.run(
            ["git", "rev-parse", "HEAD"],
            cwd=str(PROJECT_ROOT),
            capture_output=True,
            text=True,
            check=True
        )
        return result.stdout.strip()
    except subprocess.CalledProcessError:
        return None

def check_for_updates():
    """Check if there are updates available from the remote repository."""
    if not check_if_git_repo():
        print("‚ö†Ô∏è  Not a git repository. Auto-update is only available for git installations.")
        return False
    
    try:
        # Fetch latest changes from remote
        print("üîç Checking for updates...")
        subprocess.run(
            ["git", "fetch", "origin"],
            cwd=str(PROJECT_ROOT),
            capture_output=True,
            check=True
        )
        
        # Check if there are any differences
        result = subprocess.run(
            ["git", "rev-list", "--count", "HEAD..origin/main"],
            cwd=str(PROJECT_ROOT),
            capture_output=True,
            text=True,
            check=True
        )
        
        commits_behind = int(result.stdout.strip())
        return commits_behind > 0
    except subprocess.CalledProcessError as e:
        print(f"‚ö†Ô∏è  Could not check for updates: {e}")
        return False
    except ValueError:
        print("‚ö†Ô∏è  Could not parse update check result.")
        return False

def perform_update():
    """Perform git pull to update the repository."""
    try:
        print("üì• Updating Wave...")
        
        # Get current commit before update
        old_commit = get_current_commit_hash()
        
        # Perform git pull
        result = subprocess.run(
            ["git", "pull", "origin", "main"],
            cwd=str(PROJECT_ROOT),
            capture_output=True,
            text=True,
            check=True
        )
        
        # Get new commit after update
        new_commit = get_current_commit_hash()
        
        if old_commit != new_commit:
            print("‚úÖ Wave updated successfully!")
            print(f"   Updated from {old_commit[:8] if old_commit else 'unknown'} to {new_commit[:8] if new_commit else 'unknown'}")
            
            # Update dependencies after pulling new code
            print("üîÑ Updating dependencies...")
            setup_environment()
            
        else:
            print("‚úÖ Wave is already up to date.")
        
        # Update timestamp
        update_last_check_time()
        return True
        
    except subprocess.CalledProcessError as e:
        print(f"‚ùå Failed to update Wave: {e}")
        print("   You may need to resolve conflicts or check your git configuration.")
        return False

def auto_update_check():
    """Perform automatic update check and update if necessary."""
    if not should_check_for_updates():
        return
    
    if check_for_updates():
        print("üÜï Updates available for Wave!")
        try:
            # Ask user if they want to update (with timeout for automated environments)
            print("   Updating automatically in 5 seconds... (Press Ctrl+C to skip)")
            time.sleep(5)
            perform_update()
        except KeyboardInterrupt:
            print("\n‚è≠Ô∏è  Skipping update.")
            update_last_check_time()  # Don't ask again for 24 hours
    else:
        print("‚úÖ Wave is up to date.")
        update_last_check_time()

def setup_environment():
    """Set up Python virtual environment and install dependencies."""
    print("üåä Setting up Wave environment...")
    
    # Create virtual environment
    venv_path = PROJECT_ROOT / "venv"
    if not venv_path.exists():
        print("Creating Python virtual environment...")
        subprocess.run([sys.executable, "-m", "venv", str(venv_path)], check=True)
    
    # Get python and pip paths
    if os.name == 'nt':  # Windows
        python_exe = venv_path / "Scripts" / "python.exe"
        pip_exe = venv_path / "Scripts" / "pip.exe"
    else:  # Unix-like
        python_exe = venv_path / "bin" / "python"
        pip_exe = venv_path / "bin" / "pip"
    
    # Install backend dependencies
    print("Installing Python dependencies...")
    backend_reqs = PROJECT_ROOT / "wave_backend" / "requirements.txt"
    subprocess.run([str(pip_exe), "install", "-r", str(backend_reqs)], check=True)
    
    # Install frontend dependencies if Node.js is available
    frontend_path = PROJECT_ROOT / "wave_frontend"
    if frontend_path.exists():
        try:
            print("Installing Node.js dependencies...")
            subprocess.run(["npm", "install"], cwd=str(frontend_path), check=True)
        except FileNotFoundError:
            print("‚ö†Ô∏è  Node.js not found. Please install Node.js to set up the frontend.")
    
    # Create data directory
    data_dir = PROJECT_ROOT / "data"
    data_dir.mkdir(exist_ok=True)
    
    print("‚úÖ Environment setup complete!")

def start_services():
    """Start Wave backend and frontend services."""
    # Perform auto-update check before starting services
    auto_update_check()
    
    print("üåä Starting Wave services...")
    
    # Check if virtual environment exists
    venv_path = PROJECT_ROOT / "venv"
    if not venv_path.exists():
        print("‚ùå Virtual environment not found. Please run 'wave setup' first.")
        return
    
    # Get python executable path
    if os.name == 'nt':  # Windows
        python_exe = venv_path / "Scripts" / "python.exe"
    else:  # Unix-like
        python_exe = venv_path / "bin" / "python"
    
    # Start backend API
    backend_script = PROJECT_ROOT / "wave_backend" / "main.py"
    if backend_script.exists():
        print("Starting backend API on port 8080...")
        backend_process = subprocess.Popen([
            str(python_exe), str(backend_script)
        ], cwd=str(PROJECT_ROOT))
        
        # Give backend time to start
        time.sleep(3)
        
        # Start frontend if available
        frontend_path = PROJECT_ROOT / "wave_frontend"
        frontend_process = None
        if frontend_path.exists():
            try:
                print("Starting frontend UI on port 5173...")
                frontend_process = subprocess.Popen([
                    "npm", "run", "dev"
                ], cwd=str(frontend_path))
            except FileNotFoundError:
                print("‚ö†Ô∏è  Node.js not found. Frontend will not start.")
        
        print("‚úÖ Wave is running!")
        print("   Backend API: http://localhost:8080")
        if frontend_process:
            print("   Frontend UI: http://localhost:5173")
        print("\nPress Ctrl+C to stop...")
        
        try:
            # Wait for processes
            if frontend_process:
                backend_process.wait()
                frontend_process.wait()
            else:
                backend_process.wait()
        except KeyboardInterrupt:
            print("\nüõë Stopping Wave services...")
            backend_process.terminate()
            if frontend_process:
                frontend_process.terminate()
            backend_process.wait()
            if frontend_process:
                frontend_process.wait()
            print("‚úÖ Wave stopped.")
    else:
        print("‚ùå Backend main.py not found. Please ensure the project is properly set up.")

def stop_services():
    """Stop all Wave services."""
    print("üõë Stopping Wave services...")
    
    # Kill any running Wave processes
    if os.name != 'nt':  # Unix-like systems
        try:
            # Find and kill backend processes
            subprocess.run(["pkill", "-f", "wave_backend"], check=False)
            # Find and kill frontend processes
            subprocess.run(["pkill", "-f", "vite.*wave_frontend"], check=False)
        except subprocess.CalledProcessError:
            pass
    
    print("‚úÖ Wave services stopped.")

def main():
    """Main CLI entry point."""
    parser = argparse.ArgumentParser(description="Wave - Local LLM-Driven Crypto Trading Bot")
    subparsers = parser.add_subparsers(dest='command', help='Available commands')
    
    # Setup command
    setup_parser = subparsers.add_parser('setup', help='Set up Wave environment')
    
    # Start command  
    start_parser = subparsers.add_parser('start', help='Start Wave services')
    
    # Stop command
    stop_parser = subparsers.add_parser('stop', help='Stop Wave services')
    
    # Update command
    update_parser = subparsers.add_parser('update', help='Update Wave to the latest version')
    
    args = parser.parse_args()
    
    if args.command == 'setup':
        setup_environment()
    elif args.command == 'start':
        start_services()
    elif args.command == 'stop':
        stop_services()
    elif args.command == 'update':
        if perform_update():
            print("\nüéâ Update completed successfully!")
        else:
            print("\n‚ùå Update failed. Please check the error messages above.")
    else:
        parser.print_help()

if __name__ == "__main__":
    main()