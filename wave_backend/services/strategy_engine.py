"""
Strategy Runtime and Execution Engine
Coordinates strategy execution, risk management, and order placement.
"""

import asyncio
from abc import ABC, abstractmethod
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
from dataclasses import dataclass, asdict
from enum import Enum
import logging
import json
import uuid

from ..services.event_bus import EventBus
from ..services.market_data import MarketDataService, OHLCV, Ticker
from ..services.paper_broker import PaperBroker
from ..services.risk_engine import RiskEngine, RiskViolation
from ..services.indicators import IndicatorEngine
from ..models.trading import Order, OrderSide, OrderType, OrderStatus

logger = logging.getLogger(__name__)

class StrategyStatus(str, Enum):
    INACTIVE = "inactive"
    ACTIVE = "active"
    PAUSED = "paused"
    ERROR = "error"
    STOPPING = "stopping"

class SignalType(str, Enum):
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"
    CLOSE_LONG = "close_long"
    CLOSE_SHORT = "close_short"

@dataclass
class TradingSignal:
    """Trading signal generated by strategy."""
    strategy_id: str
    symbol: str
    signal_type: SignalType
    strength: float  # 0.0 - 1.0
    price: float
    quantity: Optional[float] = None
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    metadata: Dict[str, Any] = None
    timestamp: datetime = None
    
    def __post_init__(self):
        if self.timestamp is None:
            self.timestamp = datetime.utcnow()
        if self.metadata is None:
            self.metadata = {}

@dataclass
class StrategyState:
    """Strategy execution state."""
    strategy_id: str
    status: StrategyStatus
    last_signal: Optional[TradingSignal]
    last_execution: Optional[datetime]
    positions: Dict[str, Dict]
    performance: Dict[str, float]
    error_message: Optional[str] = None
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            'strategy_id': self.strategy_id,
            'status': self.status.value,
            'last_signal': asdict(self.last_signal) if self.last_signal else None,
            'last_execution': self.last_execution.isoformat() if self.last_execution else None,
            'positions': self.positions,
            'performance': self.performance,
            'error_message': self.error_message
        }

class BaseStrategy(ABC):
    """Base class for all trading strategies."""
    
    def __init__(self, strategy_id: str, config: Dict[str, Any]):
        self.strategy_id = strategy_id
        self.config = config
        self.name = config.get('name', 'Unknown Strategy')
        self.symbols = config.get('symbols', [])
        self.timeframe = config.get('timeframe', '1h')
        
        # Strategy state
        self.status = StrategyStatus.INACTIVE
        self.last_signals: Dict[str, TradingSignal] = {}
        self.positions: Dict[str, Dict] = {}
        
        # Performance tracking
        self.performance = {
            'total_signals': 0,
            'successful_trades': 0,
            'total_pnl': 0.0,
            'win_rate': 0.0,
            'avg_return': 0.0,
            'max_drawdown': 0.0,
            'sharpe_ratio': 0.0
        }
    
    @abstractmethod
    async def analyze(self, 
                     symbol: str, 
                     market_data: List[OHLCV], 
                     indicators: Dict[str, Any]) -> Optional[TradingSignal]:
        """Analyze market data and generate trading signals."""
        pass
    
    @abstractmethod
    def get_required_indicators(self) -> List[Dict[str, Any]]:
        """Get list of required technical indicators."""
        pass
    
    def validate_config(self) -> List[str]:
        """Validate strategy configuration."""
        errors = []
        
        if not self.symbols:
            errors.append("No symbols specified")
        
        if not self.timeframe:
            errors.append("No timeframe specified")
        
        return errors
    
    async def on_signal_generated(self, signal: TradingSignal):
        """Called when a signal is generated."""
        self.last_signals[signal.symbol] = signal
        self.performance['total_signals'] += 1
    
    async def on_order_filled(self, order: Order, fill_price: float, fill_quantity: float):
        """Called when an order is filled."""
        # Update performance metrics
        # This would be implemented based on specific strategy logic
        pass
    
    def get_status(self) -> Dict[str, Any]:
        """Get strategy status."""
        return {
            'strategy_id': self.strategy_id,
            'name': self.name,
            'status': self.status.value,
            'symbols': self.symbols,
            'timeframe': self.timeframe,
            'last_signals': {
                symbol: asdict(signal) for symbol, signal in self.last_signals.items()
            },
            'performance': self.performance
        }

class StrategyEngine:
    """Strategy runtime and execution engine."""
    
    def __init__(self, 
                 event_bus: EventBus,
                 market_data_service: MarketDataService,
                 paper_broker: PaperBroker,
                 risk_engine: RiskEngine):
        self.event_bus = event_bus
        self.market_data_service = market_data_service
        self.paper_broker = paper_broker
        self.risk_engine = risk_engine
        self.indicator_engine = IndicatorEngine()
        
        # Strategy management
        self.strategies: Dict[str, BaseStrategy] = {}
        self.strategy_states: Dict[str, StrategyState] = {}
        
        # Execution tracking
        self.pending_orders: Dict[str, Order] = {}
        self.execution_history: List[Dict[str, Any]] = []
        
        # Background tasks
        self.execution_task: Optional[asyncio.Task] = None
        self.monitoring_task: Optional[asyncio.Task] = None
        
        # Configuration
        self.execution_interval = 30  # seconds
        self.max_concurrent_strategies = 10
        
        # Subscribe to events
        self.event_bus.subscribe("fills", self._handle_fill_event)
        self.event_bus.subscribe("orders", self._handle_order_event)
    
    async def start(self):
        """Start strategy engine."""
        logger.info("Starting strategy engine...")
        
        # Start background tasks
        self.execution_task = asyncio.create_task(self._execution_loop())
        self.monitoring_task = asyncio.create_task(self._monitoring_loop())
        
        logger.info("Strategy engine started")
    
    async def stop(self):
        """Stop strategy engine."""
        logger.info("Stopping strategy engine...")
        
        # Stop all strategies
        for strategy_id in list(self.strategies.keys()):
            await self.stop_strategy(strategy_id)
        
        # Cancel background tasks
        if self.execution_task:
            self.execution_task.cancel()
        if self.monitoring_task:
            self.monitoring_task.cancel()
        
        # Wait for tasks to complete
        try:
            if self.execution_task:
                await self.execution_task
            if self.monitoring_task:
                await self.monitoring_task
        except asyncio.CancelledError:
            pass
        
        logger.info("Strategy engine stopped")
    
    async def register_strategy(self, strategy: BaseStrategy) -> bool:
        """Register a new strategy."""
        try:
            # Validate strategy
            errors = strategy.validate_config()
            if errors:
                logger.error(f"Strategy validation failed: {errors}")
                return False
            
            # Check limits
            if len(self.strategies) >= self.max_concurrent_strategies:
                logger.error("Maximum concurrent strategies reached")
                return False
            
            # Register strategy
            self.strategies[strategy.strategy_id] = strategy
            
            # Initialize state
            self.strategy_states[strategy.strategy_id] = StrategyState(
                strategy_id=strategy.strategy_id,
                status=StrategyStatus.INACTIVE,
                last_signal=None,
                last_execution=None,
                positions={},
                performance=strategy.performance.copy()
            )
            
            # Subscribe to market data for strategy symbols
            for symbol in strategy.symbols:
                await self.market_data_service.subscribe_to_symbol(symbol)
            
            logger.info(f"Strategy registered: {strategy.strategy_id}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to register strategy {strategy.strategy_id}: {e}")
            return False
    
    async def unregister_strategy(self, strategy_id: str) -> bool:
        """Unregister a strategy."""
        try:
            if strategy_id not in self.strategies:
                return False
            
            # Stop strategy if running
            if self.strategy_states[strategy_id].status == StrategyStatus.ACTIVE:
                await self.stop_strategy(strategy_id)
            
            # Remove from tracking
            strategy = self.strategies[strategy_id]
            
            # Unsubscribe from market data
            for symbol in strategy.symbols:
                await self.market_data_service.unsubscribe_from_symbol(symbol)
            
            # Clean up
            del self.strategies[strategy_id]
            del self.strategy_states[strategy_id]
            
            logger.info(f"Strategy unregistered: {strategy_id}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to unregister strategy {strategy_id}: {e}")
            return False
    
    async def start_strategy(self, strategy_id: str) -> bool:
        """Start a strategy."""
        try:
            if strategy_id not in self.strategies:
                logger.error(f"Strategy not found: {strategy_id}")
                return False
            
            strategy = self.strategies[strategy_id]
            state = self.strategy_states[strategy_id]
            
            if state.status == StrategyStatus.ACTIVE:
                logger.warning(f"Strategy already active: {strategy_id}")
                return True
            
            # Update status
            strategy.status = StrategyStatus.ACTIVE
            state.status = StrategyStatus.ACTIVE
            
            # Emit event
            await self.event_bus.publish("strategies", {
                "type": "strategy_started",
                "strategy_id": strategy_id,
                "name": strategy.name
            })
            
            logger.info(f"Strategy started: {strategy_id}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to start strategy {strategy_id}: {e}")
            await self._set_strategy_error(strategy_id, str(e))
            return False
    
    async def stop_strategy(self, strategy_id: str) -> bool:
        """Stop a strategy."""
        try:
            if strategy_id not in self.strategies:
                return False
            
            strategy = self.strategies[strategy_id]
            state = self.strategy_states[strategy_id]
            
            if state.status != StrategyStatus.ACTIVE:
                return True
            
            # Update status
            strategy.status = StrategyStatus.STOPPING
            state.status = StrategyStatus.STOPPING
            
            # Cancel any pending orders for this strategy
            await self._cancel_strategy_orders(strategy_id)
            
            # Update final status
            strategy.status = StrategyStatus.INACTIVE
            state.status = StrategyStatus.INACTIVE
            
            # Emit event
            await self.event_bus.publish("strategies", {
                "type": "strategy_stopped",
                "strategy_id": strategy_id,
                "name": strategy.name
            })
            
            logger.info(f"Strategy stopped: {strategy_id}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to stop strategy {strategy_id}: {e}")
            return False
    
    async def pause_strategy(self, strategy_id: str) -> bool:
        """Pause a strategy."""
        try:
            if strategy_id not in self.strategies:
                return False
            
            strategy = self.strategies[strategy_id]
            state = self.strategy_states[strategy_id]
            
            if state.status != StrategyStatus.ACTIVE:
                return False
            
            strategy.status = StrategyStatus.PAUSED
            state.status = StrategyStatus.PAUSED
            
            logger.info(f"Strategy paused: {strategy_id}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to pause strategy {strategy_id}: {e}")
            return False
    
    async def resume_strategy(self, strategy_id: str) -> bool:
        """Resume a paused strategy."""
        try:
            if strategy_id not in self.strategies:
                return False
            
            strategy = self.strategies[strategy_id]
            state = self.strategy_states[strategy_id]
            
            if state.status != StrategyStatus.PAUSED:
                return False
            
            strategy.status = StrategyStatus.ACTIVE
            state.status = StrategyStatus.ACTIVE
            
            logger.info(f"Strategy resumed: {strategy_id}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to resume strategy {strategy_id}: {e}")
            return False
    
    async def _execution_loop(self):
        """Main execution loop for strategies."""
        while True:
            try:
                # Execute all active strategies
                for strategy_id, strategy in self.strategies.items():
                    state = self.strategy_states[strategy_id]
                    
                    if state.status != StrategyStatus.ACTIVE:
                        continue
                    
                    try:
                        await self._execute_strategy(strategy_id, strategy)
                        state.last_execution = datetime.utcnow()
                        
                    except Exception as e:
                        logger.error(f"Strategy execution error {strategy_id}: {e}")
                        await self._set_strategy_error(strategy_id, str(e))
                
                # Wait for next execution cycle
                await asyncio.sleep(self.execution_interval)
                
            except asyncio.CancelledError:
                break
            except Exception as e:
                logger.error(f"Error in strategy execution loop: {e}")
                await asyncio.sleep(10)
    
    async def _execute_strategy(self, strategy_id: str, strategy: BaseStrategy):
        """Execute a single strategy."""
        
        for symbol in strategy.symbols:
            try:
                # Get market data
                ohlcv_data = await self.market_data_service.get_ohlcv(
                    symbol, strategy.timeframe, limit=200
                )
                
                if not ohlcv_data or len(ohlcv_data) < 50:
                    logger.warning(f"Insufficient data for {symbol}")
                    continue
                
                # Get required indicators
                required_indicators = strategy.get_required_indicators()
                
                # Prepare data for indicators
                market_data_dict = {
                    'open': [candle.open for candle in ohlcv_data],
                    'high': [candle.high for candle in ohlcv_data],
                    'low': [candle.low for candle in ohlcv_data],
                    'close': [candle.close for candle in ohlcv_data],
                    'volume': [candle.volume for candle in ohlcv_data]
                }
                
                # Calculate indicators
                indicators = {}
                for indicator_config in required_indicators:
                    indicator_name = indicator_config['name']
                    indicator_params = indicator_config.get('params', {})
                    
                    result = self.indicator_engine.calculate_indicator(
                        indicator_name, market_data_dict, **indicator_params
                    )
                    
                    if result:
                        indicators[indicator_name] = result
                
                # Generate signal
                signal = await strategy.analyze(symbol, ohlcv_data, indicators)
                
                if signal:
                    await self._process_signal(signal, strategy)
                    await strategy.on_signal_generated(signal)
                    
            except Exception as e:
                logger.error(f"Error executing strategy {strategy_id} for {symbol}: {e}")
    
    async def _process_signal(self, signal: TradingSignal, strategy: BaseStrategy):
        """Process a trading signal."""
        try:
            if signal.signal_type == SignalType.HOLD:
                return
            
            # Get current market data
            ticker = await self.market_data_service.get_ticker(signal.symbol)
            if not ticker:
                logger.warning(f"No ticker data for {signal.symbol}")
                return
            
            current_price = ticker.last
            
            # Determine order parameters
            order_side = None
            if signal.signal_type in [SignalType.BUY]:
                order_side = OrderSide.BUY
            elif signal.signal_type in [SignalType.SELL, SignalType.CLOSE_LONG]:
                order_side = OrderSide.SELL
            
            if not order_side:
                return
            
            # Calculate position size
            portfolio_value = self.paper_broker.get_portfolio_value()
            position_value = portfolio_value * 0.1  # 10% position size by default
            quantity = position_value / current_price
            
            # Override with signal quantity if provided
            if signal.quantity:
                quantity = signal.quantity
            
            # Get current positions
            positions = self.paper_broker.get_positions()
            positions_dict = {pos['symbol']: pos for pos in positions}
            
            # Validate with risk engine
            order = Order(
                id=str(uuid.uuid4()),
                exchange_id=1,
                symbol=signal.symbol,
                side=order_side,
                qty=quantity,
                type=OrderType.MARKET,
                status=OrderStatus.PENDING,
                created_at=datetime.utcnow(),
                updated_at=datetime.utcnow()
            )
            
            is_approved, violations = await self.risk_engine.validate_order(
                order, positions_dict, portfolio_value, current_price
            )
            
            if not is_approved:
                logger.warning(f"Order rejected by risk engine: {[v.message for v in violations]}")
                
                # Emit rejection event
                await self.event_bus.publish("strategies", {
                    "type": "signal_rejected",
                    "strategy_id": signal.strategy_id,
                    "symbol": signal.symbol,
                    "signal_type": signal.signal_type,
                    "violations": [v.message for v in violations]
                })
                return
            
            # Place order
            placed_order = await self.paper_broker.place_order(
                symbol=signal.symbol,
                side=order_side,
                quantity=quantity,
                order_type=OrderType.MARKET,
                client_order_id=f"{signal.strategy_id}_{signal.symbol}_{datetime.utcnow().timestamp()}"
            )
            
            # Track order
            self.pending_orders[placed_order.id] = placed_order
            
            # Record order with risk engine
            await self.risk_engine.record_order(placed_order)
            
            # Record execution
            execution_record = {
                'strategy_id': signal.strategy_id,
                'signal': asdict(signal),
                'order_id': placed_order.id,
                'order_side': order_side.value,
                'quantity': quantity,
                'expected_price': current_price,
                'timestamp': datetime.utcnow().isoformat()
            }
            
            self.execution_history.append(execution_record)
            
            # Emit signal execution event
            await self.event_bus.publish("strategies", {
                "type": "signal_executed",
                "strategy_id": signal.strategy_id,
                "signal": asdict(signal),
                "order_id": placed_order.id,
                "quantity": quantity,
                "price": current_price
            })
            
            logger.info(f"Signal executed: {signal.strategy_id} {signal.signal_type} {signal.symbol}")
            
        except Exception as e:
            logger.error(f"Failed to process signal: {e}")
            
            # Emit error event
            await self.event_bus.publish("strategies", {
                "type": "signal_error",
                "strategy_id": signal.strategy_id,
                "symbol": signal.symbol,
                "error": str(e)
            })
    
    async def _handle_fill_event(self, event):
        """Handle order fill events."""
        try:
            fill_data = event.data
            order_id = fill_data.get('fill', {}).get('order_id')
            
            if order_id and order_id in self.pending_orders:
                order = self.pending_orders[order_id]
                
                # Find strategy that placed this order
                strategy_id = None
                for execution in self.execution_history:
                    if execution['order_id'] == order_id:
                        strategy_id = execution['strategy_id']
                        break
                
                if strategy_id and strategy_id in self.strategies:
                    strategy = self.strategies[strategy_id]
                    
                    # Notify strategy
                    await strategy.on_order_filled(
                        order, 
                        fill_data['fill']['price'], 
                        fill_data['fill']['quantity']
                    )
                    
                    # Update strategy performance
                    await self._update_strategy_performance(strategy_id, fill_data)
                
                # Remove from pending orders
                del self.pending_orders[order_id]
                
        except Exception as e:
            logger.error(f"Error handling fill event: {e}")
    
    async def _handle_order_event(self, event):
        """Handle order status events."""
        try:
            order_data = event.data
            
            if order_data.get('type') == 'order_canceled':
                order_id = order_data.get('order_id')
                if order_id and order_id in self.pending_orders:
                    del self.pending_orders[order_id]
                    
        except Exception as e:
            logger.error(f"Error handling order event: {e}")
    
    async def _update_strategy_performance(self, strategy_id: str, fill_data: Dict):
        """Update strategy performance metrics."""
        try:
            if strategy_id not in self.strategies:
                return
            
            strategy = self.strategies[strategy_id]
            
            # Update basic metrics
            # This would calculate actual P&L, win rate, etc. based on fills
            # For now, just increment successful trades
            strategy.performance['successful_trades'] += 1
            
            # Calculate win rate
            if strategy.performance['total_signals'] > 0:
                strategy.performance['win_rate'] = (
                    strategy.performance['successful_trades'] / 
                    strategy.performance['total_signals']
                )
            
            # Update strategy state
            if strategy_id in self.strategy_states:
                self.strategy_states[strategy_id].performance = strategy.performance.copy()
                
        except Exception as e:
            logger.error(f"Error updating strategy performance: {e}")
    
    async def _cancel_strategy_orders(self, strategy_id: str):
        """Cancel all pending orders for a strategy."""
        try:
            orders_to_cancel = []
            
            for execution in self.execution_history:
                if (execution['strategy_id'] == strategy_id and 
                    execution['order_id'] in self.pending_orders):
                    orders_to_cancel.append(execution['order_id'])
            
            for order_id in orders_to_cancel:
                await self.paper_broker.cancel_order(order_id)
                if order_id in self.pending_orders:
                    del self.pending_orders[order_id]
                    
        except Exception as e:
            logger.error(f"Error canceling strategy orders: {e}")
    
    async def _set_strategy_error(self, strategy_id: str, error_message: str):
        """Set strategy to error state."""
        try:
            if strategy_id in self.strategies:
                self.strategies[strategy_id].status = StrategyStatus.ERROR
            
            if strategy_id in self.strategy_states:
                self.strategy_states[strategy_id].status = StrategyStatus.ERROR
                self.strategy_states[strategy_id].error_message = error_message
            
            # Emit error event
            await self.event_bus.publish("strategies", {
                "type": "strategy_error",
                "strategy_id": strategy_id,
                "error": error_message
            })
            
        except Exception as e:
            logger.error(f"Error setting strategy error state: {e}")
    
    async def _monitoring_loop(self):
        """Background monitoring loop."""
        while True:
            try:
                # Update portfolio state for risk engine
                portfolio_value = self.paper_broker.get_portfolio_value()
                positions = self.paper_broker.get_positions()
                positions_dict = {pos['symbol']: pos for pos in positions}
                
                # Calculate daily P&L (mock for now)
                daily_pnl = 0.0
                
                await self.risk_engine.update_portfolio_state(
                    portfolio_value, positions_dict, daily_pnl
                )
                
                # Clean up old execution history (keep 24 hours)
                cutoff = datetime.utcnow() - timedelta(hours=24)
                self.execution_history = [
                    exec_rec for exec_rec in self.execution_history
                    if datetime.fromisoformat(exec_rec['timestamp']) > cutoff
                ]
                
                await asyncio.sleep(60)  # Monitor every minute
                
            except asyncio.CancelledError:
                break
            except Exception as e:
                logger.error(f"Error in strategy monitoring loop: {e}")
                await asyncio.sleep(30)
    
    def get_strategies(self) -> List[Dict[str, Any]]:
        """Get all strategies."""
        return [
            {
                **strategy.get_status(),
                **self.strategy_states[strategy_id].to_dict()
            }
            for strategy_id, strategy in self.strategies.items()
        ]
    
    def get_strategy(self, strategy_id: str) -> Optional[Dict[str, Any]]:
        """Get specific strategy."""
        if strategy_id not in self.strategies:
            return None
        
        strategy = self.strategies[strategy_id]
        state = self.strategy_states[strategy_id]
        
        return {
            **strategy.get_status(),
            **state.to_dict()
        }
    
    def get_execution_history(self, strategy_id: str = None) -> List[Dict[str, Any]]:
        """Get execution history."""
        if strategy_id:
            return [
                exec_rec for exec_rec in self.execution_history
                if exec_rec['strategy_id'] == strategy_id
            ]
        
        return self.execution_history.copy()
    
    def get_engine_status(self) -> Dict[str, Any]:
        """Get strategy engine status."""
        active_strategies = sum(
            1 for state in self.strategy_states.values()
            if state.status == StrategyStatus.ACTIVE
        )
        
        return {
            'total_strategies': len(self.strategies),
            'active_strategies': active_strategies,
            'pending_orders': len(self.pending_orders),
            'execution_history_count': len(self.execution_history),
            'last_execution': max(
                (state.last_execution for state in self.strategy_states.values() 
                 if state.last_execution),
                default=None
            )
        }